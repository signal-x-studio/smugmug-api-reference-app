/**
 * Bulk Selection & Operations Components
 * 
 * Provides comprehensive multi-select functionality and bulk operations
 * for photo management with agent coordination and natural language processing.
 */

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Photo } from '../types';

// Type definitions
export interface BulkOperationResult {
  success: boolean;
  operation: string;
  processed: number;
  failed: number;
  errors?: OperationError[];
  rollbackToken?: string;
}

export interface OperationError {
  photoId: string;
  error: string;
  code?: string;
}

export interface OperationProgress {
  operation: string;
  progress: number;
  currentFile?: string;
  completed: number;
  total: number;
  estimatedTime?: number;
}

export interface BulkOperation {
  type: string;
  label: string;
  icon: string;
  destructive?: boolean;
  requiresConfirmation?: boolean;
  maxPhotos?: number;
  supportedFormats?: string[];
}

export interface CommandParseResult {
  operation: string;
  parameters: Record<string, any>;
  confidence: number;
  suggestions?: string[];
}

export interface SelectionStats {
  count: number;
  totalSize: number;
  formats: Record<string, number>;
  dateRange: { earliest: Date; latest: Date };
}

// Props interfaces
export interface ResultsGridProps {
  photos: Photo[];
  selectionMode?: boolean;
  selectedIds?: string[];
  onSelectionChange?: (selectedIds: string[]) => void;
  showSelectAll?: boolean;
  showSelectionStats?: boolean;
  gridColumns?: number;
}

export interface BulkOperationsPanelProps {
  selectedPhotos: Photo[];
  onOperationExecute: (operation: any) => void;
  operationProgress?: OperationProgress;
  operationStatus?: any;
  executor?: BulkOperationExecutor;
  selectionManager?: BulkSelectionManager;
  showOperationHistory?: boolean;
  validation?: {
    maxPhotos: number;
    maxFileSize: string;
    allowedFormats: string[];
  };
  commandProcessor?: (command: string) => Promise<any>;
  showCommandHelp?: boolean;
  useAgentContext?: boolean;
  exposeToAgents?: boolean;
}

export interface OperationConfirmationDialogProps {
  operation: {
    type: string;
    photoCount: number;
    destructive?: boolean;
    preview?: any;
  };
  onConfirm: (operation: any) => void;
  onCancel: () => void;
}

/**
 * Results Grid with Multi-Select Functionality
 */
export const ResultsGrid: React.FC<ResultsGridProps> = ({
  photos,
  selectionMode = false,
  selectedIds = [],
  onSelectionChange,
  showSelectAll = false,
  showSelectionStats = false,
  gridColumns = 4
}) => {
  const [selectionStats, setSelectionStats] = useState<SelectionStats | null>(null);

  // Calculate selection statistics
  useEffect(() => {
    if (showSelectionStats && selectedIds.length > 0) {
      const selectedPhotos = photos.filter(p => selectedIds.includes(p.id));
      const stats: SelectionStats = {
        count: selectedPhotos.length,
        totalSize: selectedPhotos.length * 2.1, // Estimate 2.1MB per photo
        formats: {},
        dateRange: {
          earliest: new Date(Math.min(...selectedPhotos.map(p => p.metadata?.takenAt?.getTime() || 0))),
          latest: new Date(Math.max(...selectedPhotos.map(p => p.metadata?.takenAt?.getTime() || 0)))
        }
      };

      selectedPhotos.forEach(photo => {
        const ext = photo.filename?.split('.').pop()?.toLowerCase() || 'unknown';
        stats.formats[ext] = (stats.formats[ext] || 0) + 1;
      });

      setSelectionStats(stats);
    } else {
      setSelectionStats(null);
    }
  }, [selectedIds, photos, showSelectionStats]);

  const handlePhotoSelect = (photoId: string, selected: boolean) => {
    if (!onSelectionChange) return;
    
    if (selected) {
      onSelectionChange([...selectedIds, photoId]);
    } else {
      onSelectionChange(selectedIds.filter(id => id !== photoId));
    }
  };

  const handleSelectAll = () => {
    if (!onSelectionChange) return;
    onSelectionChange(photos.map(p => p.id));
  };

  const handleSelectNone = () => {
    if (!onSelectionChange) return;
    onSelectionChange([]);
  };

  const handleKeyDown = (event: React.KeyboardEvent, photoId: string) => {
    if (event.key === ' ') {
      event.preventDefault();
      const isSelected = selectedIds.includes(photoId);
      handlePhotoSelect(photoId, !isSelected);
    }
  };

  return (
    <div className="results-grid">
      {showSelectAll && selectionMode && (
        <div className="selection-controls">
          <button onClick={handleSelectAll}>Select All</button>
          <button onClick={handleSelectNone}>Select None</button>
          {selectionStats && (
            <div className="selection-stats">
              <span>{selectionStats.count} photos selected</span>
              <span>Total size: ~{selectionStats.totalSize.toFixed(1)} MB</span>
            </div>
          )}
        </div>
      )}

      <div 
        className="photo-grid"
        style={{ gridTemplateColumns: `repeat(${gridColumns}, 1fr)` }}
      >
        {photos.map(photo => (
          <div
            key={photo.id}
            data-testid={`photo-${photo.id}`}
            className={`photo-item ${selectedIds.includes(photo.id) ? 'selected' : ''}`}
            tabIndex={0}
            onKeyDown={(e) => handleKeyDown(e, photo.id)}
          >
            {selectionMode && (
              <input
                type="checkbox"
                checked={selectedIds.includes(photo.id)}
                onChange={(e) => handlePhotoSelect(photo.id, e.target.checked)}
                className="photo-checkbox"
              />
            )}
            
            <img
              src={photo.thumbnailUrl || `/thumbs/${photo.id}`}
              alt={photo.filename}
              className="photo-thumbnail"
            />
            
            <div className="photo-info">
              <span className="photo-filename">{photo.filename}</span>
              <span className="photo-metadata">
                {photo.metadata?.location} • {photo.metadata?.camera}
              </span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

/**
 * Bulk Operations Panel
 */
export const BulkOperationsPanel: React.FC<BulkOperationsPanelProps> = ({
  selectedPhotos,
  onOperationExecute,
  operationProgress,
  operationStatus,
  executor,
  showCommandHelp = false,
  useAgentContext = false,
  exposeToAgents = false
}) => {
  const [commandInput, setCommandInput] = useState('');
  const [commandSuggestions, setCommandSuggestions] = useState<string[]>([]);
  const [showConfirmation, setShowConfirmation] = useState<any>(null);

  const availableOperations: BulkOperation[] = [
    {
      type: 'download',
      label: 'Download Selected',
      icon: '📥',
      maxPhotos: 1000
    },
    {
      type: 'album_add',
      label: 'Add to Album',
      icon: '📁',
      maxPhotos: 500
    },
    {
      type: 'export_metadata',
      label: 'Export Metadata',
      icon: '📋',
      supportedFormats: ['json', 'csv', 'xml']
    },
    {
      type: 'analyze',
      label: 'Analyze Photos',
      icon: '🔍',
      maxPhotos: 100
    },
    {
      type: 'tag',
      label: 'Tag Photos',
      icon: '🏷️'
    },
    {
      type: 'delete',
      label: 'Delete Selected',
      icon: '🗑️',
      destructive: true,
      requiresConfirmation: true
    }
  ];

  // Expose to agent state if requested
  useEffect(() => {
    if (exposeToAgents && typeof window !== 'undefined') {
      window.agentState = window.agentState || {};
      window.agentState.bulkOperations = {
        current: {
          selectedCount: selectedPhotos.length,
          availableOperations: availableOperations.map(op => op.type)
        },
        actions: {
          execute: (operation: string, params: any) => {
            onOperationExecute({ type: operation, parameters: params });
          }
        },
        lastUpdated: Date.now()
      };
    }
  }, [selectedPhotos, exposeToAgents, onOperationExecute, availableOperations]);

  // Generate command suggestions
  useEffect(() => {
    if (showCommandHelp && commandInput.length > 2) {
      const suggestions = [
        'download all selected photos',
        'download photos to folder',
        'download as zip file',
        'add tags to selected photos',
        'create album with selected photos',
        'export metadata as CSV',
        'analyze selected photos'
      ].filter(suggestion => 
        suggestion.toLowerCase().includes(commandInput.toLowerCase())
      );
      setCommandSuggestions(suggestions);
    } else {
      setCommandSuggestions([]);
    }
  }, [commandInput, showCommandHelp]);

  const handleOperationClick = (operation: BulkOperation) => {
    if (selectedPhotos.length === 0) return;

    if (operation.requiresConfirmation) {
      setShowConfirmation({
        type: operation.type,
        photoCount: selectedPhotos.length,
        destructive: operation.destructive
      });
    } else {
      onOperationExecute({
        type: operation.type,
        photos: selectedPhotos
      });
    }
  };

  const handleCommandSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!commandInput.trim()) return;

    try {
      if (executor) {
        const parseResult = await executor.parseCommand(commandInput);
        if (parseResult.confidence > 0.7) {
          onOperationExecute({
            type: parseResult.operation,
            parameters: parseResult.parameters,
            photos: selectedPhotos
          });
          setCommandInput('');
        } else {
          // Show suggestions for low confidence commands
          setCommandSuggestions(parseResult.suggestions || []);
        }
      }
    } catch (error) {
      console.error('Command processing error:', error);
    }
  };

  const isOperationDisabled = (operation: BulkOperation): boolean => {
    if (selectedPhotos.length === 0) return true;
    if (operation.maxPhotos && selectedPhotos.length > operation.maxPhotos) return true;
    return false;
  };

  // Add contextual suggestions if using agent context
  const contextualSuggestions = useMemo(() => {
    if (!useAgentContext || typeof window === 'undefined') return [];
    
    const agentState = window.agentState?.photoSearch;
    if (!agentState) return [];

    const suggestions = [];
    if (agentState.current?.lastQuery?.includes('beach')) {
      suggestions.push('Create "Hawaii Beach Photos" album');
    }
    if (agentState.current?.currentFilters?.location) {
      suggestions.push(`Tag as ${agentState.current.currentFilters.location} photos`);
    }
    
    return suggestions;
  }, [useAgentContext, selectedPhotos]);

  return (
    <div className="bulk-operations-panel">
      <div className="panel-header">
        <h3>Bulk Operations</h3>
        <span className="selected-count">
          {selectedPhotos.length} photos selected
        </span>
      </div>

      {operationProgress && (
        <div className="operation-progress">
          <div className="progress-header">
            <span>Downloading... {Math.round(operationProgress.progress * 100)}%</span>
            <span>Current: {operationProgress.currentFile}</span>
          </div>
          <progress 
            value={Math.round(operationProgress.progress * 100)}
            max="100"
            className="progress-bar"
          />
        </div>
      )}

      {operationStatus?.status === 'partial_failure' && (
        <div className="operation-status partial-failure">
          <h4>Partial Success</h4>
          <p>{operationStatus.completed} of {operationStatus.completed + operationStatus.failed} photos processed</p>
          <div className="status-actions">
            <button>Rollback Changes</button>
            <button>Retry Failed</button>
          </div>
        </div>
      )}

      <div className="operations-grid">
        {availableOperations.map(operation => (
          <button
            key={operation.type}
            className={`operation-button ${operation.destructive ? 'destructive' : ''}`}
            disabled={isOperationDisabled(operation)}
            onClick={() => handleOperationClick(operation)}
          >
            <span className="operation-icon">{operation.icon}</span>
            <span className="operation-label">{operation.label}</span>
          </button>
        ))}
      </div>

      {showCommandHelp && (
        <div className="command-interface">
          <form onSubmit={handleCommandSubmit}>
            <input
              type="text"
              value={commandInput}
              onChange={(e) => setCommandInput(e.target.value)}
              placeholder="Type bulk operation command..."
              className="command-input"
            />
            <button type="submit">Execute</button>
          </form>
          
          {commandSuggestions.length > 0 && (
            <div className="command-suggestions">
              {commandSuggestions.map(suggestion => (
                <button
                  key={suggestion}
                  className="suggestion"
                  onClick={() => setCommandInput(suggestion)}
                >
                  {suggestion}
                </button>
              ))}
            </div>
          )}
        </div>
      )}

      {contextualSuggestions.length > 0 && (
        <div className="contextual-suggestions">
          <h4>Suggested Actions</h4>
          {contextualSuggestions.map(suggestion => (
            <button key={suggestion} className="contextual-suggestion">
              {suggestion}
            </button>
          ))}
        </div>
      )}

      {showConfirmation && (
        <OperationConfirmationDialog
          operation={showConfirmation}
          onConfirm={(operation) => {
            onOperationExecute({
              type: operation.type,
              confirmed: true,
              photos: selectedPhotos
            });
            setShowConfirmation(null);
          }}
          onCancel={() => setShowConfirmation(null)}
        />
      )}
    </div>
  );
};

/**
 * Operation Confirmation Dialog
 */
export const OperationConfirmationDialog: React.FC<OperationConfirmationDialogProps> = ({
  operation,
  onConfirm,
  onCancel
}) => {
  const getConfirmationMessage = () => {
    switch (operation.type) {
      case 'delete':
        return {
          title: 'Confirm Delete',
          message: `Are you sure you want to delete ${operation.photoCount} photos?`,
          warning: 'This action cannot be undone.',
          confirmText: 'Delete Photos',
          confirmClass: 'destructive'
        };
      case 'tag':
        return {
          title: 'Add Tags',
          message: `Add tags to ${operation.photoCount} photos?`,
          confirmText: 'Add Tags'
        };
      default:
        return {
          title: 'Confirm Operation',
          message: `Execute operation on ${operation.photoCount} photos?`,
          confirmText: 'Confirm'
        };
    }
  };

  const config = getConfirmationMessage();

  return (
    <div className="confirmation-overlay">
      <div className="confirmation-dialog">
        <h3>{config.title}</h3>
        <p>{config.message}</p>
        
        {config.warning && (
          <p className="warning">{config.warning}</p>
        )}

        {operation.preview && (
          <div className="operation-preview">
            <h4>Operation Preview</h4>
            <p>{operation.preview.changes}</p>
            {operation.preview.newTags && (
              <div className="tag-preview">
                <span>New tags: </span>
                {operation.preview.newTags.map((tag: string) => (
                  <span key={tag} className="tag">{tag}</span>
                ))}
              </div>
            )}
          </div>
        )}

        <div className="dialog-actions">
          <button onClick={onCancel}>Cancel</button>
          <button 
            className={config.confirmClass || ''}
            onClick={() => onConfirm({ type: operation.type })}
          >
            {config.confirmText}
          </button>
        </div>
      </div>
    </div>
  );
};

/**
 * Bulk Selection Manager
 */
export class BulkSelectionManager {
  private selections = new Map<string, string[]>();
  private operationHistory: any[] = [];

  addSelection(key: string, photoIds: string[]) {
    this.selections.set(key, photoIds);
  }

  getSelection(key: string): string[] {
    return this.selections.get(key) || [];
  }

  clearSelection(key: string) {
    this.selections.delete(key);
  }

  addToHistory(operation: any) {
    this.operationHistory.push({
      ...operation,
      timestamp: Date.now(),
      id: Math.random().toString(36).substr(2, 9)
    });
  }

  getHistory(): any[] {
    return [...this.operationHistory].reverse();
  }
}

/**
 * Bulk Operation Executor
 */
export class BulkOperationExecutor {
  private context: Record<string, any> = {};

  setContext(context: Record<string, any>) {
    this.context = context;
  }

  async parseCommand(command: string): Promise<CommandParseResult> {
    const lowerCommand = command.toLowerCase();

    // Download commands
    if (lowerCommand.includes('download')) {
      const format = lowerCommand.includes('zip') ? 'zip' : 'individual';
      return {
        operation: 'download',
        parameters: { format, target: 'selected' },
        confidence: 0.9
      };
    }

    // Tag commands
    if (lowerCommand.includes('tag') || lowerCommand.includes('add tags')) {
      const tags = this.extractTags(command);
      const suggestedTags = this.generateSuggestedTags();
      
      return {
        operation: 'tag',
        parameters: { 
          tags, 
          action: 'add',
          suggestedTags 
        },
        confidence: tags.length > 0 ? 0.8 : 0.4
      };
    }

    // Album commands
    if (lowerCommand.includes('album') && lowerCommand.includes('create')) {
      const albumName = this.extractAlbumName(command);
      return {
        operation: 'album_create',
        parameters: { albumName, addPhotos: true },
        confidence: albumName ? 0.85 : 0.5
      };
    }

    // Low confidence - provide suggestions
    return {
      operation: 'unknown',
      parameters: {},
      confidence: 0.1,
      suggestions: [
        'download selected photos',
        'add tags to photos',
        'create album with photos'
      ]
    };
  }

  async execute(options: {
    operation: string;
    photos: any[];
    batchSize?: number;
    onProgress?: (progress: number) => void;
  }): Promise<BulkOperationResult> {
    const { operation, photos, batchSize = 50, onProgress } = options;
    
    const result: BulkOperationResult = {
      success: true,
      operation,
      processed: 0,
      failed: 0,
      errors: []
    };

    // Process in batches
    for (let i = 0; i < photos.length; i += batchSize) {
      const batch = photos.slice(i, Math.min(i + batchSize, photos.length));
      
      try {
        // Simulate batch processing
        await new Promise(resolve => setTimeout(resolve, 100));
        result.processed += batch.length;
        
        if (onProgress) {
          onProgress(result.processed / photos.length);
        }
      } catch (error) {
        result.failed += batch.length;
        result.success = false;
        
        batch.forEach(photo => {
          result.errors?.push({
            photoId: photo.id,
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
      }
    }

    return result;
  }

  private extractTags(command: string): string[] {
    const tagMatches = command.match(/(?:tag|tags)\s+.*?(?:as|with)?\s+(.*?)(?:\s+to|\s+for|$)/i);
    if (tagMatches?.[1]) {
      return tagMatches[1]
        .split(/\s+and\s+|\s*,\s*|\s+/)
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
    }
    return [];
  }

  private extractAlbumName(command: string): string {
    const nameMatch = command.match(/(?:album|collection)\s+(?:called|named)?\s*["']?([^"']+)["']?/i);
    return nameMatch?.[1]?.trim() || '';
  }

  private generateSuggestedTags(): string[] {
    const suggestions = [];
    
    if (this.context.lastQuery?.includes('beach')) {
      suggestions.push('beach', 'vacation');
    }
    if (this.context.currentLocation) {
      suggestions.push(this.context.currentLocation);
    }
    
    return suggestions;
  }
}
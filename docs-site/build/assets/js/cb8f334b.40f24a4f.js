"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[638],{1171:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"implementation/service-layer","title":"Service Layer Architecture","description":"The service layer provides clean abstractions for external APIs, making the application maintainable and testable. This pattern separates business logic from UI concerns and enables easy mocking during development.","source":"@site/docs/implementation/service-layer.md","sourceDirName":"implementation","slug":"/implementation/service-layer","permalink":"/smugmug-api-reference-app/implementation/service-layer","draft":false,"unlisted":false,"editUrl":"https://github.com/signal-x-studio/smugmug-api-reference-app/tree/main/docs-site/docs/implementation/service-layer.md","tags":[],"version":"current","lastUpdatedBy":null,"lastUpdatedAt":null,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"React Component Patterns","permalink":"/smugmug-api-reference-app/implementation/react-patterns"}}');var i=r(4848),a=r(8453);const s={sidebar_position:3},o="Service Layer Architecture",c={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Mock Service Pattern",id:"mock-service-pattern",level:2},{value:"Mock Service Implementation",id:"mock-service-implementation",level:3},{value:"Benefits of Mock Service Pattern",id:"benefits-of-mock-service-pattern",level:3},{value:"AI Service Integration",id:"ai-service-integration",level:2},{value:"Core AI Service Structure",id:"core-ai-service-structure",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Consistent Error Response Structure",id:"consistent-error-response-structure",level:3},{value:"Retry Logic Implementation",id:"retry-logic-implementation",level:3},{value:"Service Configuration",id:"service-configuration",level:2},{value:"Environment-Based Configuration",id:"environment-based-configuration",level:3},{value:"Service Factory Pattern",id:"service-factory-pattern",level:3},{value:"Testing Service Layer",id:"testing-service-layer",level:2},{value:"Service Testing Patterns",id:"service-testing-patterns",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"service-layer-architecture",children:"Service Layer Architecture"})}),"\n",(0,i.jsx)(n.p,{children:"The service layer provides clean abstractions for external APIs, making the application maintainable and testable. This pattern separates business logic from UI concerns and enables easy mocking during development."}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Service layer structure\nservices/\n\u251c\u2500\u2500 geminiService.ts      # AI/Gemini Vision integration\n\u251c\u2500\u2500 mockSmugMugService.ts # Development mock service (active)\n\u2514\u2500\u2500 smugmugService.ts     # OAuth reference implementation\n"})}),"\n",(0,i.jsx)(n.h2,{id:"mock-service-pattern",children:"Mock Service Pattern"}),"\n",(0,i.jsx)(n.p,{children:"During development, the application uses a mock service that simulates SmugMug API behavior without requiring OAuth setup or external dependencies."}),"\n",(0,i.jsx)(n.h3,{id:"mock-service-implementation",children:"Mock Service Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// services/mockSmugMugService.ts\nimport { SmugMugService, Album, Photo, SmugMugNode } from '../types';\n\nclass MockSmugMugService implements SmugMugService {\n  async getCurrentUser() {\n    // Simulate API delay\n    await this.delay(500);\n    \n    return {\n      id: 'mock-user-123',\n      name: 'Demo User',\n      nickname: 'demo',\n      email: 'demo@example.com'\n    };\n  }\n\n  async getNodeTree(): Promise<SmugMugNode[]> {\n    await this.delay(800);\n    \n    return [\n      {\n        id: 'node-1',\n        name: 'Travel Photos',\n        type: 'folder',\n        children: [\n          { id: 'album-1', name: 'Europe 2023', type: 'album' },\n          { id: 'album-2', name: 'Japan Trip', type: 'album' }\n        ]\n      },\n      {\n        id: 'node-2', \n        name: 'Family',\n        type: 'folder',\n        children: [\n          { id: 'album-3', name: 'Holiday Gatherings', type: 'album' }\n        ]\n      }\n    ];\n  }\n\n  async getAlbumPhotos(albumId: string): Promise<Photo[]> {\n    await this.delay(600);\n    \n    // Generate mock photos based on album\n    const photoCount = Math.floor(Math.random() * 20) + 5;\n    const photos: Photo[] = [];\n    \n    for (let i = 1; i <= photoCount; i++) {\n      photos.push({\n        id: `${albumId}-photo-${i}`,\n        title: `Photo ${i}`,\n        filename: `IMG_${1000 + i}.jpg`,\n        url: `https://picsum.photos/800/600?random=${albumId}-${i}`,\n        thumbnailUrl: `https://picsum.photos/200/150?random=${albumId}-${i}`,\n        uploadDate: this.randomDate(),\n        status: this.randomStatus()\n      });\n    }\n    \n    return photos;\n  }\n\n  private async delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private randomDate(): string {\n    const start = new Date(2023, 0, 1);\n    const end = new Date();\n    const date = new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));\n    return date.toISOString();\n  }\n\n  private randomStatus(): PhotoStatus {\n    const statuses = [\n      PhotoStatus.Uploaded,\n      PhotoStatus.AIProcessed, \n      PhotoStatus.ReviewNeeded,\n      PhotoStatus.Approved\n    ];\n    return statuses[Math.floor(Math.random() * statuses.length)];\n  }\n}\n\nexport const smugmugService = new MockSmugMugService();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-mock-service-pattern",children:"Benefits of Mock Service Pattern"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Development Independence"}),": No external API dependencies during development"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictable Testing"}),": Consistent data for UI testing and development"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Fast responses without network delays"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cost Efficiency"}),": No API usage costs during development"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offline Development"}),": Works without internet connectivity"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"ai-service-integration",children:"AI Service Integration"}),"\n",(0,i.jsx)(n.p,{children:"The Gemini service demonstrates production-ready AI integration with proper error handling and structured responses."}),"\n",(0,i.jsx)(n.h3,{id:"core-ai-service-structure",children:"Core AI Service Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// services/geminiService.ts\nimport { GoogleGenerativeAI } from '@google/genai';\n\nexport class GeminiService {\n  private genAI: GoogleGenerativeAI;\n  private model: any;\n\n  constructor(apiKey: string) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.model = this.genAI.getGenerativeModel({ \n      model: \"gemini-1.5-flash\",\n      generationConfig: {\n        responseMimeType: \"application/json\"\n      }\n    });\n  }\n\n  async generatePhotoMetadata(\n    image: File, \n    customInstructions: string = ''\n  ): Promise<ImageMetadata> {\n    try {\n      // Convert image to proper format\n      const imagePart = await this.fileToGenerativePart(image);\n      \n      // Build structured prompt\n      const prompt = this.buildMetadataPrompt(customInstructions);\n      \n      // Generate with schema enforcement\n      const result = await this.model.generateContent([prompt, imagePart]);\n      const responseText = result.response.text();\n      \n      // Parse and validate response\n      const metadata = JSON.parse(responseText) as ImageMetadata;\n      this.validateMetadata(metadata);\n      \n      return metadata;\n      \n    } catch (error) {\n      throw this.handleAIError(error);\n    }\n  }\n\n  private validateMetadata(metadata: any): void {\n    const required = ['title', 'description', 'keywords'];\n    \n    for (const field of required) {\n      if (!metadata[field]) {\n        throw new Error(`Missing required field: ${field}`);\n      }\n    }\n    \n    if (!Array.isArray(metadata.keywords)) {\n      throw new Error('Keywords must be an array');\n    }\n  }\n\n  private handleAIError(error: any): Error {\n    if (error.message?.includes('quota')) {\n      return new Error('AI service quota exceeded. Please try again later.');\n    } else if (error.message?.includes('invalid')) {\n      return new Error('Invalid image format. Please use JPEG, PNG, or WebP.');\n    } else {\n      return new Error(`AI processing failed: ${error.message}`);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"consistent-error-response-structure",children:"Consistent Error Response Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface ServiceError {\n  type: 'network' | 'quota' | 'invalid_input' | 'server' | 'unknown';\n  message: string;\n  retryable: boolean;\n  details?: any;\n}\n\nclass ServiceErrorHandler {\n  static handle(error: any): ServiceError {\n    // Network errors\n    if (error.code === 'NETWORK_ERROR' || !navigator.onLine) {\n      return {\n        type: 'network',\n        message: 'Network connection lost. Please check your internet connection.',\n        retryable: true\n      };\n    }\n    \n    // Rate limiting / quota errors\n    if (error.message?.includes('quota') || error.status === 429) {\n      return {\n        type: 'quota',\n        message: 'Service quota exceeded. Please try again later.',\n        retryable: true\n      };\n    }\n    \n    // Invalid input\n    if (error.status >= 400 && error.status < 500) {\n      return {\n        type: 'invalid_input',\n        message: error.message || 'Invalid request. Please check your input.',\n        retryable: false\n      };\n    }\n    \n    // Server errors\n    if (error.status >= 500) {\n      return {\n        type: 'server',\n        message: 'Service temporarily unavailable. Please try again.',\n        retryable: true\n      };\n    }\n    \n    // Unknown errors\n    return {\n      type: 'unknown',\n      message: error.message || 'An unexpected error occurred.',\n      retryable: false,\n      details: error\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"retry-logic-implementation",children:"Retry Logic Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class RetryableService {\n  static async withRetry<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n    baseDelay: number = 1000\n  ): Promise<T> {\n    let lastError: ServiceError;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        const serviceError = ServiceErrorHandler.handle(error);\n        lastError = serviceError;\n        \n        // Don't retry non-retryable errors\n        if (!serviceError.retryable) {\n          throw serviceError;\n        }\n        \n        // Don't retry on last attempt\n        if (attempt === maxRetries) {\n          throw serviceError;\n        }\n        \n        // Exponential backoff\n        const delay = baseDelay * Math.pow(2, attempt - 1);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n    \n    throw lastError!;\n  }\n}\n\n// Usage example\nconst generateMetadataWithRetry = async (image: File, instructions: string) => {\n  return RetryableService.withRetry(\n    () => geminiService.generatePhotoMetadata(image, instructions),\n    3, // max 3 retries\n    1000 // start with 1 second delay\n  );\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"service-configuration",children:"Service Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"environment-based-configuration",children:"Environment-Based Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// config/services.ts\ninterface ServiceConfig {\n  gemini: {\n    apiKey: string;\n    model: string;\n    timeout: number;\n  };\n  smugmug: {\n    baseUrl: string;\n    timeout: number;\n    mockMode: boolean;\n  };\n}\n\nconst getServiceConfig = (): ServiceConfig => {\n  const apiKey = import.meta.env.VITE_API_KEY || process.env.API_KEY;\n  \n  if (!apiKey) {\n    throw new Error('API_KEY environment variable is required');\n  }\n  \n  return {\n    gemini: {\n      apiKey,\n      model: 'gemini-1.5-flash',\n      timeout: 30000\n    },\n    smugmug: {\n      baseUrl: 'https://api.smugmug.com/api/v2',\n      timeout: 15000,\n      mockMode: process.env.NODE_ENV === 'development'\n    }\n  };\n};\n\nexport const serviceConfig = getServiceConfig();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"service-factory-pattern",children:"Service Factory Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// services/factory.ts\ninterface ServiceFactory {\n  createSmugMugService(): SmugMugService;\n  createGeminiService(): GeminiService;\n}\n\nclass ProductionServiceFactory implements ServiceFactory {\n  createSmugMugService(): SmugMugService {\n    if (serviceConfig.smugmug.mockMode) {\n      return new MockSmugMugService();\n    }\n    return new RealSmugMugService(serviceConfig.smugmug);\n  }\n  \n  createGeminiService(): GeminiService {\n    return new GeminiService(serviceConfig.gemini.apiKey);\n  }\n}\n\nclass TestServiceFactory implements ServiceFactory {\n  createSmugMugService(): SmugMugService {\n    return new MockSmugMugService();\n  }\n  \n  createGeminiService(): GeminiService {\n    return new MockGeminiService(); // Returns predictable test data\n  }\n}\n\nexport const serviceFactory: ServiceFactory = \n  process.env.NODE_ENV === 'test' \n    ? new TestServiceFactory()\n    : new ProductionServiceFactory();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-service-layer",children:"Testing Service Layer"}),"\n",(0,i.jsx)(n.h3,{id:"service-testing-patterns",children:"Service Testing Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// __tests__/services/geminiService.test.ts\ndescribe('GeminiService', () => {\n  let geminiService: GeminiService;\n  let mockFile: File;\n  \n  beforeEach(() => {\n    geminiService = new GeminiService('test-api-key');\n    mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });\n  });\n  \n  it('should generate metadata for valid image', async () => {\n    const metadata = await geminiService.generatePhotoMetadata(mockFile);\n    \n    expect(metadata).toHaveProperty('title');\n    expect(metadata).toHaveProperty('description');\n    expect(metadata).toHaveProperty('keywords');\n    expect(Array.isArray(metadata.keywords)).toBe(true);\n  });\n  \n  it('should handle quota exceeded error', async () => {\n    // Mock quota exceeded response\n    jest.spyOn(geminiService, 'generatePhotoMetadata')\n      .mockRejectedValue(new Error('quota exceeded'));\n    \n    await expect(\n      geminiService.generatePhotoMetadata(mockFile)\n    ).rejects.toThrow('AI service quota exceeded');\n  });\n  \n  it('should validate response structure', async () => {\n    // Mock invalid response\n    jest.spyOn(JSON, 'parse')\n      .mockReturnValue({ title: 'test' }); // missing required fields\n    \n    await expect(\n      geminiService.generatePhotoMetadata(mockFile)\n    ).rejects.toThrow('Missing required field');\n  });\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"This service layer architecture provides a clean separation of concerns, making the application maintainable, testable, and easy to extend with new external services."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next"}),": Explore the complete project and see these patterns in action by running the application locally."]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);
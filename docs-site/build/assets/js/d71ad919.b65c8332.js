"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[33],{175:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"implementation/ai-integration","title":"AI Integration Patterns","description":"This guide demonstrates the structured approach to AI integration used in this project. The key insight: treat AI APIs like any other external service with proper abstractions, error handling, and predictable responses.","source":"@site/docs/implementation/ai-integration.md","sourceDirName":"implementation","slug":"/implementation/ai-integration","permalink":"/smugmug-api-reference-app/implementation/ai-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/signal-x-studio/smugmug-api-reference-app/tree/main/docs-site/docs/implementation/ai-integration.md","tags":[],"version":"current","lastUpdatedBy":"Abelino Chavez","lastUpdatedAt":1759015570000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Multi-Agent Development Workflow","permalink":"/smugmug-api-reference-app/ai-development/multi-agent-workflow"},"next":{"title":"React Component Patterns","permalink":"/smugmug-api-reference-app/implementation/react-patterns"}}');var i=t(4848),s=t(8453),a=t(6540);function o(e){var n=e.title,t=void 0===n?"Try the API Schema":n,r=e.description,s=void 0===r?"See how schema enforcement works in practice":r,o=(0,a.useState)({title:"Beautiful sunset landscape",description:"A stunning sunset over mountains with golden light",keywords:["landscape","sunset","mountains","nature"]}),c=o[0],l=o[1],d=(0,a.useState)(null),h=d[0],m=d[1],p=(0,a.useState)(!1),g=p[0],u=p[1],f=function(e,n){l(function(t){var r;return Object.assign({},t,((r={})[e]=n,r))})},y={width:"100%",padding:"0.5rem",border:"1px solid #d1d5db",borderRadius:"4px",fontSize:"0.9rem",marginBottom:"0.5rem"};return(0,i.jsxs)("div",{className:"api-demo-container",style:{margin:"1rem 0"},children:[(0,i.jsxs)("div",{className:"card",children:[(0,i.jsxs)("div",{className:"card__header",children:[(0,i.jsx)("h3",{children:t}),(0,i.jsx)("p",{children:s})]}),(0,i.jsx)("div",{className:"card__body",children:(0,i.jsxs)("div",{className:"row",children:[(0,i.jsxs)("div",{className:"col col--6",children:[(0,i.jsx)("h4",{children:"Input Data"}),(0,i.jsxs)("div",{style:{marginBottom:"0.5rem"},children:[(0,i.jsx)("label",{style:{display:"block",fontWeight:"600",marginBottom:"0.25rem"},children:"Title:"}),(0,i.jsx)("input",{type:"text",style:y,value:c.title,onChange:function(e){return f("title",e.target.value)}})]}),(0,i.jsxs)("div",{style:{marginBottom:"0.5rem"},children:[(0,i.jsx)("label",{style:{display:"block",fontWeight:"600",marginBottom:"0.25rem"},children:"Description:"}),(0,i.jsx)("textarea",{style:Object.assign({},y,{minHeight:"80px"}),value:c.description,onChange:function(e){return f("description",e.target.value)}})]}),(0,i.jsxs)("div",{style:{marginBottom:"1rem"},children:[(0,i.jsx)("label",{style:{display:"block",fontWeight:"600",marginBottom:"0.25rem"},children:"Keywords (comma-separated):"}),(0,i.jsx)("input",{type:"text",style:y,value:c.keywords.join(", "),onChange:function(e){return n=e.target.value,t=n.split(",").map(function(e){return e.trim()}).filter(function(e){return e.length>0}),void f("keywords",t);var n,t}})]}),(0,i.jsx)("button",{className:"button button--primary",onClick:function(){u(!0),setTimeout(function(){var e=Object.assign({},c,{technicalDetails:{estimatedLocation:"Mountain region",timeOfDay:"Golden hour",weather:"Clear skies"},confidence:.94,processingTime:"1.2s"});m(e),u(!1)},1200)},disabled:g,children:g?"Processing...":"Generate Metadata"})]}),(0,i.jsxs)("div",{className:"col col--6",children:[(0,i.jsx)("h4",{children:"Schema-Validated Response"}),(0,i.jsx)("div",{style:{background:"#f8f9fa",border:"1px solid #e9ecef",borderRadius:"4px",padding:"1rem",maxHeight:"300px",overflowY:"auto",fontSize:"0.85rem",fontFamily:"monospace"},children:g?(0,i.jsx)("div",{style:{textAlign:"center",color:"#666",fontStyle:"italic"},children:"\ud83d\udd04 Processing with Gemini Vision..."}):h?(0,i.jsx)("pre",{children:JSON.stringify(h,null,2)}):(0,i.jsx)("div",{style:{color:"#999",fontStyle:"italic",textAlign:"center"},children:'Click "Generate Metadata" to see the structured response'})})]})]})})]}),(0,i.jsxs)("div",{className:"card",style:{marginTop:"1rem"},children:[(0,i.jsxs)("div",{className:"card__header",children:[(0,i.jsx)("h4",{children:"Response Schema"}),(0,i.jsx)("p",{children:"This ensures every AI response matches the expected structure"})]}),(0,i.jsx)("div",{className:"card__body",children:(0,i.jsx)("pre",{style:{background:"#f1f3f4",border:"1px solid #dadce0",borderRadius:"4px",padding:"1rem",maxHeight:"200px",overflowY:"auto",fontSize:"0.8rem"},children:JSON.stringify({type:"object",properties:{title:{type:"string",description:"Descriptive photo title"},description:{type:"string",description:"Detailed photo description"},keywords:{type:"array",items:{type:"string"},description:"Relevant keywords for categorization"},technicalDetails:{type:"object",properties:{estimatedLocation:{type:"string"},timeOfDay:{type:"string"},weather:{type:"string"}}}},required:["title","description","keywords"]},null,2)})})]})]})}const c={sidebar_position:1},l="AI Integration Patterns",d={},h=[{value:"The Schema-First Approach",id:"the-schema-first-approach",level:2},{value:"Defining Response Schemas",id:"defining-response-schemas",level:3},{value:"Schema Benefits",id:"schema-benefits",level:3},{value:"Service Layer Architecture",id:"service-layer-architecture",level:2},{value:"Core Service Structure",id:"core-service-structure",level:3},{value:"Advanced Integration Patterns",id:"advanced-integration-patterns",level:2},{value:"Pattern 1: Batch Processing with Rate Limiting",id:"pattern-1-batch-processing-with-rate-limiting",level:3},{value:"Pattern 2: Smart Album Matching",id:"pattern-2-smart-album-matching",level:3},{value:"Pattern 3: Custom Instruction Processing",id:"pattern-3-custom-instruction-processing",level:3},{value:"Error Handling Strategies",id:"error-handling-strategies",level:2},{value:"Graceful Degradation",id:"graceful-degradation",level:3},{value:"Retry Logic with Exponential Backoff",id:"retry-logic-with-exponential-backoff",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Image Preprocessing",id:"image-preprocessing",level:3},{value:"Integration with React Components",id:"integration-with-react-components",level:2},{value:"Hook Pattern for AI Services",id:"hook-pattern-for-ai-services",level:3}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ai-integration-patterns",children:"AI Integration Patterns"})}),"\n",(0,i.jsx)(n.p,{children:"This guide demonstrates the structured approach to AI integration used in this project. The key insight: treat AI APIs like any other external service with proper abstractions, error handling, and predictable responses."}),"\n","\n",(0,i.jsx)(o,{title:"\ud83d\udd2c Interactive Schema Demo",description:"Try modifying the input data and see how schema enforcement ensures consistent AI responses"}),"\n",(0,i.jsx)(n.h2,{id:"the-schema-first-approach",children:"The Schema-First Approach"}),"\n",(0,i.jsxs)(n.p,{children:["The most critical decision for reliable AI integration is using ",(0,i.jsx)(n.strong,{children:"structured JSON responses"})," with schema enforcement. This transforms the probabilistic nature of LLMs into deterministic, API-like behavior."]}),"\n",(0,i.jsx)(n.h3,{id:"defining-response-schemas",children:"Defining Response Schemas"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// From services/geminiService.ts\nconst PHOTO_METADATA_SCHEMA = {\n  type: "object",\n  properties: {\n    title: {\n      type: "string",\n      description: "A descriptive, engaging title for the photo"\n    },\n    description: {\n      type: "string", \n      description: "Detailed description of what\'s shown in the photo"\n    },\n    keywords: {\n      type: "array",\n      items: { type: "string" },\n      description: "Relevant keywords for categorization and search"\n    },\n    technicalDetails: {\n      type: "object",\n      properties: {\n        estimatedLocation: { type: "string" },\n        timeOfDay: { type: "string" },\n        weather: { type: "string" },\n        photographyStyle: { type: "string" }\n      }\n    },\n    suggestedAlbums: {\n      type: "array",\n      items: { type: "string" },\n      description: "Suggested album names where this photo would fit"\n    }\n  },\n  required: ["title", "description", "keywords"],\n  additionalProperties: false\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"schema-benefits",children:"Schema Benefits"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictable Responses"}),": Always get the expected data structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Safety"}),": Perfect integration with TypeScript"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Prevention"}),": Invalid responses are caught early"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Schema serves as API documentation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"service-layer-architecture",children:"Service Layer Architecture"}),"\n",(0,i.jsx)(n.p,{children:"All AI interactions go through a dedicated service layer, following the same patterns as any external API integration."}),"\n",(0,i.jsx)(n.h3,{id:"core-service-structure",children:"Core Service Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// services/geminiService.ts\nimport { GoogleGenerativeAI } from '@google/genai';\n\nexport const generatePhotoMetadata = async (\n  image: File,\n  customInstructions: string,\n  apiKey: string\n): Promise<ImageMetadata> => {\n  // Input validation\n  if (!apiKey) {\n    throw new Error('API key is required for AI metadata generation');\n  }\n  \n  if (!image || !image.type.startsWith('image/')) {\n    throw new Error('Valid image file is required');\n  }\n\n  try {\n    const genAI = new GoogleGenerativeAI(apiKey);\n    const model = genAI.getGenerativeModel({ \n      model: \"gemini-1.5-flash\",\n      generationConfig: {\n        responseMimeType: \"application/json\",\n        responseSchema: PHOTO_METADATA_SCHEMA\n      }\n    });\n\n    // Convert image to the format Gemini expects\n    const imageBytes = await fileToGenerativePart(image);\n    \n    // Construct detailed prompt\n    const prompt = buildMetadataPrompt(customInstructions);\n    \n    // Make the API call with structured response\n    const result = await model.generateContent([prompt, imageBytes]);\n    const responseText = result.response.text();\n    \n    // Parse and validate the JSON response\n    const metadata = JSON.parse(responseText) as ImageMetadata;\n    \n    // Additional validation if needed\n    validateMetadata(metadata);\n    \n    return metadata;\n    \n  } catch (error) {\n    // Structured error handling\n    if (error.message?.includes('quota')) {\n      throw new Error('API quota exceeded. Please try again later.');\n    } else if (error.message?.includes('invalid')) {\n      throw new Error('Invalid image format. Please use JPEG, PNG, or WebP.');\n    } else {\n      throw new Error(`AI metadata generation failed: ${error.message}`);\n    }\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-integration-patterns",children:"Advanced Integration Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-batch-processing-with-rate-limiting",children:"Pattern 1: Batch Processing with Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const batchProcessPhotos = async (\n  photos: File[],\n  settings: AiSettings,\n  onProgress: (processed: number, total: number) => void\n): Promise<PhotoProcessingResult[]> => {\n  const results: PhotoProcessingResult[] = [];\n  const BATCH_SIZE = 3; // Process 3 photos simultaneously\n  const RATE_LIMIT_DELAY = 1000; // 1 second between batches\n  \n  for (let i = 0; i < photos.length; i += BATCH_SIZE) {\n    const batch = photos.slice(i, i + BATCH_SIZE);\n    \n    // Process batch concurrently\n    const batchPromises = batch.map(async (photo, index) => {\n      try {\n        const metadata = await generatePhotoMetadata(\n          photo, \n          settings.customInstructions, \n          settings.apiKey\n        );\n        return { success: true, photo, metadata };\n      } catch (error) {\n        return { success: false, photo, error: error.message };\n      }\n    });\n    \n    const batchResults = await Promise.all(batchPromises);\n    results.push(...batchResults);\n    \n    // Update progress\n    onProgress(results.length, photos.length);\n    \n    // Rate limiting delay between batches\n    if (i + BATCH_SIZE < photos.length) {\n      await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\n    }\n  }\n  \n  return results;\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-smart-album-matching",children:"Pattern 2: Smart Album Matching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'export const doesImageMatchPrompt = async (\n  image: File,\n  albumPrompt: string,\n  apiKey: string\n): Promise<AlbumMatchResult> => {\n  const MATCH_SCHEMA = {\n    type: "object",\n    properties: {\n      matches: { type: "boolean" },\n      confidence: { type: "number", minimum: 0, maximum: 1 },\n      reasoning: { type: "string" },\n      suggestedKeywords: {\n        type: "array",\n        items: { type: "string" }\n      }\n    },\n    required: ["matches", "confidence", "reasoning"]\n  };\n\n  const model = genAI.getGenerativeModel({ \n    model: "gemini-1.5-flash",\n    generationConfig: {\n      responseMimeType: "application/json",\n      responseSchema: MATCH_SCHEMA\n    }\n  });\n\n  const prompt = `\n    You are evaluating whether this image matches the following album criteria: "${albumPrompt}"\n    \n    Analyze the image and determine:\n    1. Does it match the criteria? (true/false)\n    2. How confident are you? (0.0 to 1.0)\n    3. What\'s your reasoning?\n    4. What keywords would help categorize this image?\n    \n    Be precise and consider both obvious and subtle matches.\n  `;\n\n  const imageBytes = await fileToGenerativePart(image);\n  const result = await model.generateContent([prompt, imageBytes]);\n  \n  return JSON.parse(result.response.text()) as AlbumMatchResult;\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-3-custom-instruction-processing",children:"Pattern 3: Custom Instruction Processing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const buildMetadataPrompt = (customInstructions: string): string => {\n  const basePrompt = `\n    You are an expert photo archivist and metadata specialist.\n    Analyze this image and generate comprehensive metadata.\n    \n    Focus on:\n    - Descriptive, engaging titles that capture the essence\n    - Detailed descriptions of visual elements, mood, and context  \n    - Relevant keywords for organization and discoverability\n    - Technical observations about lighting, composition, style\n    - Suggestions for album categorization\n  `;\n  \n  const customSection = customInstructions \n    ? `\\n\\nAdditional Instructions:\\n${customInstructions}`\n    : '';\n    \n  const formatRequirement = `\n    \n    Your response must be valid JSON matching the required schema.\n    Do not include any explanations outside the JSON structure.\n  `;\n  \n  return basePrompt + customSection + formatRequirement;\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-strategies",children:"Error Handling Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"graceful-degradation",children:"Graceful Degradation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const handleAIError = (error: Error, fallbackData?: Partial<ImageMetadata>) => {\n  // Log for debugging but don't crash the UI\n  console.error('AI Service Error:', error);\n  \n  if (error.message.includes('quota')) {\n    return {\n      title: fallbackData?.title || 'Photo',\n      description: 'AI analysis temporarily unavailable - quota exceeded',\n      keywords: fallbackData?.keywords || ['photo'],\n      aiGenerated: false,\n      error: 'quota_exceeded'\n    };\n  }\n  \n  if (error.message.includes('network')) {\n    return {\n      title: fallbackData?.title || 'Photo',\n      description: 'AI analysis failed due to network issues',\n      keywords: fallbackData?.keywords || ['photo'],\n      aiGenerated: false,\n      error: 'network_error'\n    };\n  }\n  \n  // Generic fallback\n  return {\n    title: 'Untitled Photo',\n    description: 'AI analysis not available',\n    keywords: ['photo'],\n    aiGenerated: false,\n    error: 'unknown'\n  };\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"retry-logic-with-exponential-backoff",children:"Retry Logic with Exponential Backoff"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const withRetry = async <T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> => {\n  let lastError: Error;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      \n      // Don't retry on certain errors\n      if (error.message.includes('invalid') || error.message.includes('unauthorized')) {\n        throw error;\n      }\n      \n      if (attempt < maxRetries) {\n        const delay = baseDelay * Math.pow(2, attempt - 1);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  throw lastError;\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"image-preprocessing",children:"Image Preprocessing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const fileToGenerativePart = async (file: File): Promise<GenerativePart> => {\n  // Optimize image size for API efficiency\n  const optimizedFile = await optimizeImageForAI(file);\n  \n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64Data = (reader.result as string).split(',')[1];\n      resolve({\n        inlineData: {\n          data: base64Data,\n          mimeType: optimizedFile.type\n        }\n      });\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(optimizedFile);\n  });\n};\n\nconst optimizeImageForAI = async (file: File): Promise<File> => {\n  // Skip optimization if file is already small\n  if (file.size < 1024 * 1024) { // 1MB\n    return file;\n  }\n  \n  // Create canvas for resizing\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const img = new Image();\n  \n  return new Promise((resolve) => {\n    img.onload = () => {\n      // Calculate optimal dimensions (max 1024px on longest side)\n      const maxDimension = 1024;\n      let { width, height } = img;\n      \n      if (width > height && width > maxDimension) {\n        height = (height * maxDimension) / width;\n        width = maxDimension;\n      } else if (height > maxDimension) {\n        width = (width * maxDimension) / height;\n        height = maxDimension;\n      }\n      \n      canvas.width = width;\n      canvas.height = height;\n      ctx.drawImage(img, 0, 0, width, height);\n      \n      canvas.toBlob(resolve, 'image/jpeg', 0.8);\n    };\n    \n    img.src = URL.createObjectURL(file);\n  });\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-react-components",children:"Integration with React Components"}),"\n",(0,i.jsx)(n.h3,{id:"hook-pattern-for-ai-services",children:"Hook Pattern for AI Services"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// hooks/usePhotoMetadata.ts\nexport const usePhotoMetadata = () => {\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const generateMetadata = async (\n    photo: File,\n    customInstructions: string = '',\n    apiKey: string\n  ) => {\n    setIsGenerating(true);\n    setError(null);\n    \n    try {\n      const metadata = await withRetry(() => \n        generatePhotoMetadata(photo, customInstructions, apiKey)\n      );\n      \n      return metadata;\n    } catch (err) {\n      const errorMessage = err.message || 'Failed to generate metadata';\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n  \n  return { generateMetadata, isGenerating, error };\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"This structured approach to AI integration provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reliability"})," through schema enforcement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintainability"})," via proper abstractions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"})," with optimization and batching"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Experience"})," through proper error handling"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next"}),": Explore the ",(0,i.jsx)(n.a,{href:"./react-patterns",children:"React component patterns"})," that make this AI integration seamless."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);